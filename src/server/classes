use std::borrow::{Borrow, BorrowMut};
use std::fmt::Error;
use std::io::{ErrorKind, Read, Write};
use std::net::{TcpListener, TcpStream};
use std::ops::{Deref, DerefMut};
use std::sync::{Arc, RwLock};
use std::thread;

use crate::server::cfg::Config;
use crate::constants::size;
use crate::constants::actions;
use crate::constants::size::{READ_BUFFER_SIZE, READ_BUFFER_SIZE_WITHOUT_SIZE, WRITE_BUFFER_SIZE};
use crate::constants::message_classes;
use crate::space::space::{Space, SpaceEngineType, SpaceInterface, CACHE};
use crate::console::write_errors;
use crate::utils;
use crate::utils::fastbytes::uint;

pub struct Storage {
    spaces: RwLock<Vec<Space>>,
    spaces_names: RwLock<Vec<String>>,
}

pub struct Server {
    storage: Arc<Storage>,
    is_running: bool,
    password: String,
    port: u16,
}

impl Server {
    pub(crate) fn new() -> Self {
        let config = Config::new();
        Self {
            storage: Arc::new(Storage{
                spaces: RwLock::new(Vec::with_capacity(1)),
                spaces_names: RwLock::new(Vec::with_capacity(1)),
            }),
            port: config.port,
            password: config.password,
            is_running: false,
        }
    }

    pub(crate) fn run(&mut self) {
        if self.is_running {
           return;
        }
        self.is_running = true;
        let listener_ = TcpListener::bind(format!("dbms:{}", self.port));
        let mut listener = match listener_ {
            Ok(listener) => listener,
            Err(e) => {
                panic!("Can't bind to port: {}, the error is: {:?}", self.port, e);
            }
        };
        println!("Server tcp listening on port {}", self.port);
        for stream in listener.incoming() {
            let storage= self.storage.clone();
            thread::spawn(move || {
                match stream {
                    Ok(mut stream) => {
                        Self::handle_client(storage, stream);
                    }
                    Err(e) => {
                        println!("Error: {}", e);
                    }
                }
            });
        }
    }

    #[inline(always)]
    fn handle_client(storage: Arc<Storage>, mut stream: TcpStream) {
        let mut read_buffer = [0u8; READ_BUFFER_SIZE];
        let mut write_buffer = [0u8; WRITE_BUFFER_SIZE];
        while match stream.read(&mut read_buffer) {
            Ok(0) => false,
            Ok(mut pipe_size) => {
                let real_pipe_size = uint::u32(&read_buffer[0..4]);
                while real_pipe_size != pipe_size as u32 {
                    match stream.read(&mut read_buffer[pipe_size..]) {
                        Ok(0) => {
                            break;
                        }
                        Ok(size) => {
                            pipe_size += size;
                        }
                        Err(e) => {
                            println!("Error: {}", e);
                        }
                    }
                    // TODO r
                    println!("twice read");
                }
                let message_class = uint::u8(&read_buffer[4..5]);
                let mut write_offset = 0;
                match message_class {
                    message_classes::DB => {
                        let mut offset = 5;
                        Self::handle_db_class_message(&mut stream,pipe_size, &read_buffer, offset, write_buffer, write_offset);
                    }
                    message_classes::STORAGE => {
                        let mut offset = 5;
                        Self::handle_storage_class_message(&mut stream, pipe_size, storage.clone(), &read_buffer, offset, &mut write_buffer, write_offset);
                    }
                    message_classes::SPACE => {
                        let mut offset = 7;
                        let space_id = uint::u16(&read_buffer[5..7]);
                        let mut space: &mut Space;
                        {
                            let mut spaces = storage.spaces.write().unwrap();
                            match spaces.get_mut(space_id as usize) {
                                Some(space_unwrapped) => {
                                    space = space_unwrapped;
                                }
                                None => {
                                    stream.write_all(&[actions::SPACE_NOT_FOUND]).expect("Can't write to stream");
                                    true
                                }
                            }
                        }
                        Self::handle_space_class_message(&mut stream, pipe_size, space, &read_buffer,offset, &mut write_buffer, write_offset);
                    }
                    _ => {
                        stream.write_all(&[actions::BAD_REQUEST]).expect("Can't write to stream");
                    }
                }
                true
                // let space_id = uint::u16(&read_buffer[5..7]);
                // loop {
                //     if offset >= pipe_size - 2 {
                //         break;
                //     }
                //     let size:u16 = uint::u16(&read_buffer[offset..offset+2]);
                //     if size == 65535 {
                //         let big_size:u32 = uint::u32(&read_buffer[offset+2..offset+6]);
                //         offset += 6;
                //         write_offset = Self::handle_space_message(&mut stream, storage.clone(), &read_buffer[offset..offset + big_size as usize], &mut write_buffer, write_offset);
                //         offset += big_size as usize;
                //     } else {
                //         offset += 2;
                //         write_offset = Self::handle_space_message(&mut stream, storage.clone(), &read_buffer[offset..offset + size as usize], &mut write_buffer, write_offset);
                //         offset += size as usize;
                //     }
                // }
                // stream.write_all(&write_buffer[..write_offset]).expect("Can't write to stream");
                // true
            },
            Err(e) => {
                println!("An error occurred, terminating connection with {}, error has a message: {:?}", stream.peer_addr().unwrap(), e);
                stream.shutdown(std::net::Shutdown::Both).unwrap();
                false
            }
        } {};
    }

    #[inline(always)]
    fn handle_db_class_message(stream: &mut TcpStream, mut pipe_size: usize, read_buffer: &[u8], mut read_offset: usize, mut write_buf: [u8;WRITE_BUFFER_SIZE], mut write_offset: usize) {
        loop {
            if read_offset >= pipe_size - 2 {
                break;
            }
            let size:u16 = uint::u16(&read_buffer[read_offset..read_offset+2]);
            if size == 65535 {
                let big_size:u32 = uint::u32(&read_buffer[read_offset+2..read_offset+6]);
                read_offset += 6;
                write_offset = Self::handle_db_message(stream, &read_buffer[read_offset..read_offset + big_size as usize], &mut write_buf, write_offset);
                read_offset += big_size as usize;
            } else {
                read_offset += 2;
                write_offset = Self::handle_db_message(stream, &read_buffer[read_offset..read_offset + size as usize], &mut write_buf, write_offset);
                read_offset += size as usize;
            }
        }
        stream.write_all(&write_buf[..write_offset]).expect("Can't write to stream");
    }

    #[inline(always)]
    fn handle_db_message(stream: &mut TcpStream, message: &[u8], write_buf: &mut [u8], mut write_offset: usize) -> usize {
        return match message[0] {
            actions::PING => {
                write_msg(stream, write_buf, write_offset, &[actions::PING])
            }
            _ => {
                write_msg(stream, write_buf, write_offset, &[actions::BAD_REQUEST])
            }
        }
    }

    #[inline(always)]
    fn handle_storage_class_message(stream: &mut TcpStream, mut pipe_size: usize, storage: Arc<Storage>, read_buffer: &[u8], mut read_offset: usize, mut write_buf: &mut [u8], mut write_offset: usize) {
        loop {
            if read_offset >= pipe_size - 2 {
                break;
            }
            let size:u16 = uint::u16(&read_buffer[read_offset..read_offset+2]);
            if size == 65535 {
                let big_size:u32 = uint::u32(&read_buffer[read_offset+2..read_offset+6]);
                read_offset += 6;
                write_offset = Self::handle_storage_message(stream, storage.clone(), &read_buffer[read_offset..read_offset + big_size as usize], &mut write_buf, write_offset);
                read_offset += big_size as usize;
            } else {
                read_offset += 2;
                write_offset = Self::handle_storage_message(stream, storage.clone(), &read_buffer[read_offset..read_offset + size as usize], &mut write_buf, write_offset);
                read_offset += size as usize;
            }
        }
        stream.write_all(&write_buf[..write_offset]).expect("Can't write to stream");
    }

    #[inline(always)]
    fn handle_storage_message(stream: &mut TcpStream, storage: Arc<Storage>, message: &[u8], write_buf: &mut [u8], mut write_offset: usize) -> usize {
        return match message[0] {
            actions::CREATE_SPACE => {
                let mut spaces;
                let spaces_not_unwrapped = storage.spaces.write();
                match spaces_not_unwrapped {
                    Ok(spaces_unwrapped) => {
                        spaces = spaces_unwrapped;
                    }
                    Err(_) => {
                        return write_msg(stream, write_buf, write_offset, &[actions::INTERNAL_ERROR]);
                    }
                }
                if message.len() < 7 {
                    return write_msg(stream, write_buf, write_offset, &[actions::BAD_REQUEST]);
                }
                let engine_type = message[1];
                let size = uint::u16(&message[2..4]);
                let name = String::from_utf8(message[4..].to_vec()).unwrap();
                match engine_type {
                    CACHE => {
                        match storage.spaces_names.write() {
                            Ok(mut spaces_names) => {
                                let mut i = 0;
                                for exists_name in spaces_names.iter() {
                                    if *exists_name == name {
                                        return write_msg(stream, write_buf, write_offset, &[actions::DONE, i as u8, ((i as u16) >> 8) as u8]);
                                    }
                                    i += 1;
                                }
                                spaces_names.push(name);
                            }
                            Err(_) => {
                                return write_msg(stream, write_buf, write_offset, &[actions::INTERNAL_ERROR]);
                            }
                        }
                        spaces.push(
                            Space::new(CACHE, size)
                        );
                        let l = spaces.len() - 1;
                        write_msg(stream, write_buf, write_offset, &[actions::DONE, l as u8, ((l as u16) >> 8) as u8])
                    },
                    _ => {
                        write_msg(stream, write_buf, write_offset, &[actions::BAD_REQUEST])
                    }
                }
            },
            actions::GET_SPACES_NAMES => {
                let mut spaces_names;
                let spaces_names_not_unwrapped = storage.spaces_names.read();
                match spaces_names_not_unwrapped {
                    Ok(spaces_names_unwrapped) => {
                        spaces_names = spaces_names_unwrapped;
                    }
                    Err(_) => {
                        return write_msg(stream, write_buf, write_offset, &[actions::INTERNAL_ERROR]);
                    }
                }

                let mut local_buffer = [0u8;32367];
                let mut local_offset = 1;

                local_buffer[0] = actions::DONE;
                for name in spaces_names.iter() {
                    let l = name.len() as u16;
                    local_buffer[local_offset..local_offset+2].copy_from_slice(&[l as u8, ((l >> 8) as u8)]);
                    local_buffer[local_offset+2..local_offset+2+l as usize].copy_from_slice(name.as_bytes());
                    local_offset += 2 + l as usize;
                }
                write_msg(stream, write_buf, write_offset, &local_buffer[..local_offset])
            },
            _ => {
                write_msg(stream, write_buf, write_offset, &[actions::BAD_REQUEST])
            }
        }
    }

    #[inline(always)]
    fn handle_space_class_message(stream: &mut TcpStream, mut pipe_size: usize, space: &mut Space, read_buffer: &[u8], mut read_offset: usize, mut write_buf: &mut [u8], mut write_offset: usize) {
        loop {
            if read_offset >= pipe_size - 2 {
                break;
            }
            let size:u16 = uint::u16(&read_buffer[read_offset..read_offset+2]);
            if size == 65535 {
                let big_size:u32 = uint::u32(&read_buffer[read_offset+2..read_offset+6]);
                read_offset += 6;
                write_offset = Self::handle_space_message(stream, space, &read_buffer[read_offset..read_offset + big_size as usize], &mut write_buf, write_offset);
                read_offset += big_size as usize;
            } else {
                read_offset += 2;
                write_offset = Self::handle_space_message(stream, space, &read_buffer[read_offset..read_offset + size as usize], &mut write_buf, write_offset);
                read_offset += size as usize;
            }
        }
        stream.write_all(&write_buf[..write_offset]).expect("Can't write to stream");
    }

    #[inline(always)]
    fn handle_space_message(stream: &mut TcpStream, space: &mut Space, message: &[u8], write_buf: &mut [u8], mut write_offset: usize) -> usize {
        return match message[0] {
            actions::GET => {
                let key = String::from_utf8_lossy(&message[3..]).to_string();
                let res = space.get(&key);
                if res.is_none() {
                    return write_msg(stream, write_buf, write_offset, &[actions::NOT_FOUND]);
                }
                let value = res.unwrap();
                let l = value.len() as u16;
                let mut v = Vec::with_capacity(3 + value.len());
                v.append(&mut vec![actions::DONE, l as u8, ((l >> 8) as u8)]);
                v.append(&mut value.clone());
                write_msg(stream, write_buf, write_offset, v.as_slice())
            },
            actions::INSERT => {
                let key_size = uint::u16(&message[1..3]) as usize;
                let key = String::from_utf8_lossy(&message[3..3+key_size]).to_string();
                let value_size = uint::u16(&message[3+key_size..5+key_size]) as usize;
                let value = message[5+key_size..5+key_size+value_size].to_vec();
                space.set(key, value);
                write_msg(stream, write_buf, write_offset, &[actions::DONE])
            }
            _ => {
                0
            }
        }
    }
}

#[inline(always)]
fn write_msg(stream: &mut TcpStream, buf: &mut [u8], mut offset: usize, msg: &[u8]) -> usize {
    let mut l = msg.len();

    if l + offset > READ_BUFFER_SIZE_WITHOUT_SIZE {
        stream.write(&buf).expect("Can't write to stream");
        offset = 0; // We flushed the buffer. Now we need to start from the beginning, but we still are responding for the same pipe.
    }

    // 65535 is 2 << 16 - 1
    if l < 65535 {
        buf[offset..offset+2].copy_from_slice(&[l as u8, ((l >> 8) as u8)]);
        offset += 2;
    } else {
        buf[offset..offset+6].copy_from_slice(&[255, 255, l as u8, ((l >> 8) as u8), ((l >> 16) as u8), ((l >> 24) as u8)]);
        offset += 6;
    }

    // We try to write all the message. If l > allowed size, we write a lot of times.
    let mut can_write = READ_BUFFER_SIZE - offset;
    let mut written = 0;
    while l > can_write {
        buf[offset..offset+can_write].copy_from_slice(&msg[written..can_write]);
        written += can_write;
        stream.write(&buf).expect("Can't write to stream");
        offset = 0;
        can_write = READ_BUFFER_SIZE;
    }

    buf[offset..offset+l].copy_from_slice(msg);
    return offset + l;

    // TODO r

    if l + offset > READ_BUFFER_SIZE_WITHOUT_SIZE {
        stream.write(&buf).expect("Can't write to stream");
        offset = 0; // We flushed the buffer. Now we need to start from the beginning, but we still are responding for the same pipe.
    }

    // 65535 is 2 << 16 - 1
    if l < 65535 {
        buf[offset..offset + 2].copy_from_slice(&[l as u8, ((l >> 8) as u8)]);
        offset += 2;
        buf[offset..offset + l].copy_from_slice(msg);
        offset + l
    } else {
        // Here we have offset that is 0. We fill write a response to the message by a few tries.
        let mut write_offset = 0;
        //4 bytes for the size
        let mut res = l + 4;
        buf[..4].copy_from_slice(&[res as u8, ((res >> 8) as u8), ((res >> 16) as u8), ((res >> 24) as u8)]);

        while res > 65536 {
            res -= 65536;
            //4 KB - 2 bytes to a size
            let write_size = 65534;
            stream.write(&buf[write_offset..write_offset + write_size]).expect("Can't write to stream");
            write_offset += write_size;
        }
        buf[..res].copy_from_slice(msg);
        res
    }
}